let {== @1 = @1 (\@2 @3-> @2)} in let {/= @4 = @4 (\@5 @6-> @6)} in let {EqInt = (\@a1 @a2 @f1-> @f1 @a1 @a2) &eq &neq} in let {EqChar = (\@a1 @a2 @f1-> @f1 @a1 @a2) &eq &neq} in let {showsPrec @7 = @7 (\@8 @9-> @8)} in let {show @10 = @10 (\@11 @12-> @12)} in let {showChar = \@a1 @a2 @f1 @f2-> @f1 @a1 @a2} in let {shows Show#v1 = showsPrec Show#v1 0} in let {show# Show#v771 x = showsPrec Show#v771 0 x (\@f1 @f2-> @f2)} in let {ShowInt = (\@a1 @a2 @f1-> @f1 @a1 @a2) showsPrec#Int (show# ShowInt);
showsPrec#Int p n = IF (< n 0) (. (showChar -) (shows ShowInt (- 0 n))) (let {d = chr (+ (ord 0) (mod n 10))} in let {m = div n 10} in IF (== EqInt m 0) (showChar d) (. (showsPrec ShowInt p m) (showChar d)))} in let {not @66 = IF (@66 (\-> \@f1 @f2-> @f1) (\-> \@f1 @f2-> @f2)) (@66 (\-> \@f1 @f2-> @f2) (error !?)) (@66 (error !?) (\-> \@f1 @f2-> @f1))} in let {Eq[] Eq#a = (\@a1 @a2 @f1-> @f1 @a1 @a2) (==#[] Eq#a) (/=#[] Eq#a);
/=#[] Eq#v848 xs ys = not (== (Eq[] Eq#v848) xs ys);
==#[] @109 @110 @111 = IF (@110 (\_1 _2-> \@f1 @f2-> @f2) (\-> \@f1 @f2-> @f1)) (@110 (error !?) (\-> IF (@111 (\_1 _2-> \@f1 @f2-> @f2) (\-> \@f1 @f2-> @f1)) (@111 (error !?) (\-> \@f1 @f2-> @f1)) (\@f1 @f2-> @f2))) (IF (@111 (\_1 _2-> \@f1 @f2-> @f2) (\-> \@f1 @f2-> @f1)) (@111 (error !?) (\-> \@f1 @f2-> @f2)) (IF (@110 (\_1 _2-> \@f1 @f2-> @f1) (\-> \@f1 @f2-> @f2)) (@110 (\@112 @113-> IF (@111 (\_1 _2-> \@f1 @f2-> @f1) (\-> \@f1 @f2-> @f2)) (@111 (\@114 @115-> && (== @109 @112 @114) (== (Eq[] @109) @113 @115)) (error !?)) (error Non-exhaustive patterns)) (error !?)) (error Non-exhaustive patterns)))} in let {$ f x = f x} in let {fst @13 = @13 (\@14 @15-> @14)} in let {snd @16 = @16 (\@17 @18-> @18)} in let {map @19 @20 = IF (@20 (\_1 _2-> \@f1 @f2-> @f1) (\-> \@f1 @f2-> @f2)) (@20 (\@21 @22-> (\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) (@19 @21) (map @19 @22)) (error !?)) (@20 (error !?) (\-> \@f1 @f2-> @f2))} in let {filter @23 @24 = IF (@24 (\_1 _2-> \@f1 @f2-> @f2) (\-> \@f1 @f2-> @f1)) (@24 (error !?) (\-> \@f1 @f2-> @f2)) (@24 (\@25 @26-> IF (@23 @25) ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) @25 (filter @23 @26)) (filter @23 @26)) (error !?))} in let {null @27 = IF (@27 (\_1 _2-> \@f1 @f2-> @f2) (\-> \@f1 @f2-> @f1)) (@27 (error !?) (\-> \@f1 @f2-> @f1)) (@27 (\@28 @29-> \@f1 @f2-> @f2) (error !?))} in let {head @30 = IF (@30 (\_1 _2-> \@f1 @f2-> @f2) (\-> \@f1 @f2-> @f1)) (@30 (error !?) (\-> error ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) h ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) e ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) a ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) d ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2)   ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) [ ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) ] (\@f1 @f2-> @f2)))))))))) (@30 (\@31 @32-> @31) (error !?))} in let {tail @33 = IF (@33 (\_1 _2-> \@f1 @f2-> @f2) (\-> \@f1 @f2-> @f1)) (@33 (error !?) (\-> error ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) t ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) a ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) i ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) l ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2)   ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) [ ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) ] (\@f1 @f2-> @f2)))))))))) (@33 (\@34 @35-> @35) (error !?))} in let {last @36 = IF (@36 (\_1 _2-> \@f1 @f2-> @f1) (\-> \@f1 @f2-> @f2)) (@36 (\@37 @38-> IF (@38 (\_1 _2-> \@f1 @f2-> @f2) (\-> \@f1 @f2-> @f1)) (@38 (error !?) (\-> @37)) (last @38)) (error !?)) (@36 (error !?) (\-> error ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) P ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) r ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) e ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) l ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) u ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) d ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) e ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) . ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) l ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) a ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) s ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) t ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) : ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2)   ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) e ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) m ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) p ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) t ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) y ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2)   ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) l ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) i ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) s ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) t (\@f1 @f2-> @f2)))))))))))))))))))))))))))} in let {init @39 = IF (@39 (\_1 _2-> \@f1 @f2-> @f1) (\-> \@f1 @f2-> @f2)) (@39 (\@40 @41-> IF (@41 (\_1 _2-> \@f1 @f2-> @f2) (\-> \@f1 @f2-> @f1)) (@41 (error !?) (\-> \@f1 @f2-> @f2)) ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) @40 (init @41))) (error !?)) (@39 (error !?) (\-> error ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) P ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) r ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) e ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) l ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) u ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) d ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) e ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) . ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) i ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) n ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) i ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) t ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) : ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2)   ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) e ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) m ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) p ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) t ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) y ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2)   ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) l ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) i ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) s ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) t (\@f1 @f2-> @f2)))))))))))))))))))))))))))} in let {length @42 = IF (@42 (\_1 _2-> \@f1 @f2-> @f2) (\-> \@f1 @f2-> @f1)) (@42 (error !?) (\-> 0)) (@42 (\@43 @44-> + 1 (length @44)) (error !?))} in let {foldl @45 @46 @47 = IF (@47 (\_1 _2-> \@f1 @f2-> @f2) (\-> \@f1 @f2-> @f1)) (@47 (error !?) (\-> @46)) (@47 (\@48 @49-> foldl @45 (@45 @46 @48) @49) (error !?))} in let {reverse = foldl (\x y-> (\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) y x) (\@f1 @f2-> @f2)} in let {foldr f z xs = IF (null xs) z (f (head xs) (foldr f z (tail xs)))} in let {concat xss = foldr ++ (\@f1 @f2-> @f2) xss} in let {concatMap f = . concat (map f)} in let {drop @50 @51 = IF (&eq @50 0) @51 (IF (@51 (\_1 _2-> \@f1 @f2-> @f2) (\-> \@f1 @f2-> @f1)) (@51 (error !?) (\-> \@f1 @f2-> @f2)) (@51 (\@52 @53-> drop (- @50 1) @53) (error !?)))} in let {isDigit c = let {o = ord c} in && (>= o (ord 0)) (<= o (ord 9))} in let {isUpper c = let {o = ord c} in && (>= o (ord A)) (<= o (ord Z))} in let {isLower c = let {o = ord c} in && (>= o (ord a)) (<= o (ord z))} in let {and = foldr && (\@f1 @f2-> @f1)} in let {or = foldr || (\@f1 @f2-> @f2)} in let {elem @54 @55 @56 = IF (@56 (\_1 _2-> \@f1 @f2-> @f2) (\-> \@f1 @f2-> @f1)) (@56 (error !?) (\-> \@f1 @f2-> @f2)) (@56 (\@57 @58-> || (== @54 @55 @57) (elem @54 @55 @58)) (error !?))} in let {lookup @59 @60 @61 = IF (@61 (\_1 _2-> \@f1 @f2-> @f1) (\-> \@f1 @f2-> @f2)) (@61 (\@62 @63-> @62 (\@64 @65-> IF (== @59 @60 @64) ((\@a1 @f1 @f2-> @f2 @a1) @65) (lookup @59 @60 @63))) (error !?)) (@61 (error !?) (\-> \@f1 @f2-> @f1))} in let {compare x y = IF (== EqInt x y) (\@f1 @f2 @f3-> @f2) (IF (<= x y) (\@f1 @f2 @f3-> @f1) (\@f1 @f2 @f3-> @f3))} in let {repeat x = let {xs = (\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) x xs} in xs} in let {zipWith @67 @68 @69 = IF (@68 (\_1 _2-> \@f1 @f2-> @f1) (\-> \@f1 @f2-> @f2)) (@68 (\@70 @71-> IF (@69 (\_1 _2-> \@f1 @f2-> @f1) (\-> \@f1 @f2-> @f2)) (@69 (\@72 @73-> (\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) (@67 @70 @72) (zipWith @67 @71 @73)) (error !?)) (\@f1 @f2-> @f2)) (error !?)) (\@f1 @f2-> @f2)} in let {span @74 @75 = IF (@75 (\_1 _2-> \@f1 @f2-> @f2) (\-> \@f1 @f2-> @f1)) (@75 (error !?) (\-> (\@a1 @a2 @f1-> @f1 @a1 @a2) (\@f1 @f2-> @f2) (\@f1 @f2-> @f2))) (@75 (\@76 @77-> IF (@74 @76) (let {@78 = span @74 @77} in @78 (\@79 @80-> (\@a1 @a2 @f1-> @f1 @a1 @a2) ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) @76 @79) @80)) ((\@a1 @a2 @f1-> @f1 @a1 @a2) (\@f1 @f2-> @f2) @75)) (error !?))} in let {break p = span (. not p)} in let {le @81 @82 = IF (@81 (\_1 _2-> \@f1 @f2-> @f2) (\-> \@f1 @f2-> @f1)) (@81 (error !?) (\-> \@f1 @f2-> @f1)) (IF (@82 (\_1 _2-> \@f1 @f2-> @f2) (\-> \@f1 @f2-> @f1)) (@82 (error !?) (\-> \@f1 @f2-> @f2)) (IF (@81 (\_1 _2-> \@f1 @f2-> @f1) (\-> \@f1 @f2-> @f2)) (@81 (\@83 @84-> IF (@82 (\_1 _2-> \@f1 @f2-> @f1) (\-> \@f1 @f2-> @f2)) (@82 (\@85 @86-> let {@87 = compare (ord @83) (ord @85)} in IF (@87 (\-> \@f1 @f2-> @f1) (\-> \@f1 @f2-> @f2) (\-> \@f1 @f2-> @f2)) (@87 (\-> \@f1 @f2-> @f1) (error !?) (error !?)) (IF (@87 (\-> \@f1 @f2-> @f2) (\-> \@f1 @f2-> @f1) (\-> \@f1 @f2-> @f2)) (@87 (error !?) (\-> le @84 @86) (error !?)) (@87 (error !?) (error !?) (\-> \@f1 @f2-> @f2)))) (error !?)) (error Non-exhaustive patterns)) (error !?)) (error Non-exhaustive patterns)))} in let {lines @88 = IF (@88 (\_1 _2-> \@f1 @f2-> @f2) (\-> \@f1 @f2-> @f1)) (@88 (error !?) (\-> \@f1 @f2-> @f2)) (let {@89 = break (== EqChar 
) @88} in @89 (\@90 @91-> (\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) @90 (IF (@91 (\_1 _2-> \@f1 @f2-> @f2) (\-> \@f1 @f2-> @f1)) (@91 (error !?) (\-> \@f1 @f2-> @f2)) (@91 (\@92 @93-> lines @93) (error !?)))))} in let {unlines = concatMap (\s-> ++ s ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) 
 (\@f1 @f2-> @f2)))} in let {listToMaybe @94 = IF (@94 (\_1 _2-> \@f1 @f2-> @f2) (\-> \@f1 @f2-> @f1)) (@94 (error !?) (\-> \@f1 @f2-> @f1)) (@94 (\@95 @96-> (\@a1 @f1 @f2-> @f2 @a1) @95) (error !?))} in let {find p = . listToMaybe (filter p)} in let {otherwise = \@f1 @f2-> @f1} in let {eof = chr 256} in let {fromStream @97 = @97 (\@98 @99-> IF (<= 256 (ord @98)) (\@f1 @f2-> @f2) ((\@a1 @a2 @f1 @f2-> @f1 @a1 @a2) @98 (fromStream @99)))} in let {toStream @100 = IF (@100 (\_1 _2-> \@f1 @f2-> @f2) (\-> \@f1 @f2-> @f1)) (@100 (error !?) (\-> $ ((\@a1 @a2 @f1-> @f1 @a1 @a2) 
) ((\@a1 @a2 @f1-> @f1 @a1 @a2) eof (toStream (\@f1 @f2-> @f2))))) (@100 (\@101 @102-> (\@a1 @a2 @f1-> @f1 @a1 @a2) @101 (toStream @102)) (error !?))} in let {putStr @103 @104 = toStream @103} in let {interact f = . toStream (. f fromStream)} in let {>> x y = y} in let {hSetBuffering x y = x} in let {main = interact (. unlines (. reverse lines))} in let {showsPrec# @105 @106 @107 @108 = ++ (show @105 @107) @108} in main