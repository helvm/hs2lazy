let
    { == @1 = @1
        ( \@2 @3-> @2 )
    } in let
    { /= @4 = @4
        ( \@5 @6-> @6 )
    } in let
    { EqInt = ( \@a1 @a2 @f1-> @f1 @a1 @a2 ) &eq &neq } in let
    { EqChar = ( \@a1 @a2 @f1-> @f1 @a1 @a2 ) &eq &neq } in let
    { showsPrec @7 = @7
        ( \@8 @9-> @8 )
    } in let
    { show @10 = @10
        ( \@11 @12-> @12 )
    } in let { showChar = \@a1 @a2 @f1 @f2-> @f1 @a1 @a2 } in let
    { shows Show#v1 = showsPrec Show#v1 0 } in let
    { show# Show#v795 x = showsPrec Show#v795 0 x ( \@f1 @f2-> @f2 ) } in let
    { ShowInt = ( \@a1 @a2 @f1-> @f1 @a1 @a2 ) showsPrec#Int ( show# ShowInt );
      showsPrec#Int p n = IF
        ( < n 0 )
        ( . ( showChar - )
            ( shows ShowInt
                ( - 0 n )
            )
        )
        ( let
            { d = chr
                ( +
                    ( ord 0 )
                    ( mod n 10 )
                )
            } in let
            { m = div n 10 } in IF
            ( == EqInt m 0 ) ( showChar d )
            ( . ( showsPrec ShowInt p m ) ( showChar d ) )
        )
    } in let
    { not @66 = IF
        ( @66 ( \-> \@f1 @f2-> @f1 ) ( \-> \@f1 @f2-> @f2 ) )
        ( @66 ( \-> \@f1 @f2-> @f2 ) ( error !? ) )
        ( @66 ( error !? ) ( \-> \@f1 @f2-> @f1 ) )
    } in let
    { Eq[] Eq#a = ( \@a1 @a2 @f1-> @f1 @a1 @a2 )
        ( ==#[] Eq#a )
        ( /=#[] Eq#a );
      /=#[] Eq#v872 xs ys = not
        ( ==
            ( Eq[] Eq#v872 ) xs ys
        );
      ==#[] @112 @113 @114 = IF
        ( @113 ( \_1 _2-> \@f1 @f2-> @f2 ) ( \-> \@f1 @f2-> @f1 ) )
        ( @113 ( error !? )
            ( \-> IF
                ( @114 ( \_1 _2-> \@f1 @f2-> @f2 ) ( \-> \@f1 @f2-> @f1 ) )
                ( @114 ( error !? ) ( \-> \@f1 @f2-> @f1 ) ) ( \@f1 @f2-> @f2 )
            )
        )
        ( IF
            ( @114 ( \_1 _2-> \@f1 @f2-> @f2 ) ( \-> \@f1 @f2-> @f1 ) )
            ( @114 ( error !? ) ( \-> \@f1 @f2-> @f2 ) )
            ( IF
                ( @113 ( \_1 _2-> \@f1 @f2-> @f1 ) ( \-> \@f1 @f2-> @f2 ) )
                ( @113
                    ( \@115 @116-> IF
                        ( @114 ( \_1 _2-> \@f1 @f2-> @f1 ) ( \-> \@f1 @f2-> @f2 ) )
                        ( @114
                            ( \@117 @118-> &&
                                ( == @112 @115 @117 )
                                ( ==
                                    ( Eq[] @112 ) @116 @118
                                )
                            ) ( error !? )
                        ) ( error Non-exhaustive patterns )
                    ) ( error !? )
                ) ( error Non-exhaustive patterns )
            )
        )
    } in let { $ f x = f x } in let
    { fst @13 = @13
        ( \@14 @15-> @14 )
    } in let
    { snd @16 = @16
        ( \@17 @18-> @18 )
    } in let
    { map @19 @20 = IF
        ( @20 ( \_1 _2-> \@f1 @f2-> @f1 ) ( \-> \@f1 @f2-> @f2 ) )
        ( @20
            ( \@21 @22-> ( \@a1 @a2 @f1 @f2-> @f1 @a1 @a2 )
                ( @19 @21 )
                ( map @19 @22 )
            ) ( error !? )
        )
        ( @20 ( error !? ) ( \-> \@f1 @f2-> @f2 ) )
    } in let
    { filter @23 @24 = IF
        ( @24 ( \_1 _2-> \@f1 @f2-> @f2 ) ( \-> \@f1 @f2-> @f1 ) )
        ( @24 ( error !? ) ( \-> \@f1 @f2-> @f2 ) )
        ( @24
            ( \@25 @26-> IF
                ( @23 @25 )
                ( ( \@a1 @a2 @f1 @f2-> @f1 @a1 @a2 ) @25
                    ( filter @23 @26 )
                )
                ( filter @23 @26 )
            ) ( error !? )
        )
    } in let
    { null @27 = IF
        ( @27 ( \_1 _2-> \@f1 @f2-> @f2 ) ( \-> \@f1 @f2-> @f1 ) )
        ( @27 ( error !? ) ( \-> \@f1 @f2-> @f1 ) )
        ( @27
            ( \@28 @29-> \@f1 @f2-> @f2 ) ( error !? )
        )
    } in let
    { head @30 = IF
        ( @30 ( \_1 _2-> \@f1 @f2-> @f2 ) ( \-> \@f1 @f2-> @f1 ) )
        ( @30 ( error !? )
            ( \-> error
                ( ( \@a1 @a2 @f1 @f2-> @f1 @a1 @a2 ) h
                    ( ( \@a1 @a2 @f1 @f2-> @f1 @a1 @a2 ) e
                        ( ( \@a1 @a2 @f1 @f2-> @f1 @a1 @a2 ) a
                            ( ( \@a1 @a2 @f1 @f2-> @f1 @a1 @a2 ) d
                                ( ( \@a1 @a2 @f1 @f2-> @f1 @a1 @a2 )
                                    ( ( \@a1 @a2 @f1 @f2-> @f1 @a1 @a2 )
                                        [
                                            ( ( \@a1 @a2 @f1 @f2-> @f1 @a1 @a2 )  )
                                        ] ( \@f1 @f2-> @f2 )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    }